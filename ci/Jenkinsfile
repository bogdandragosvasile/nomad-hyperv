pipeline {
    agent any
    
    environment {
        TF_WORKSPACE = 'nomad-cluster'
        ANSIBLE_INVENTORY = 'config/ansible/inventories/dev'
        NOMAD_ADDR = 'http://192.168.1.103:4646'
        CONSUL_ADDR = 'http://192.168.1.100:8500'
        JENKINS_CREDENTIALS_ID = 'nomad-consul-ssh-key'
        BACKUP_ENABLED = 'true'
        MONITORING_ENABLED = 'true'
    }
    
    parameters {
        choice(
            name: 'DEPLOYMENT_TYPE',
            choices: ['full', 'infrastructure', 'configuration', 'workloads'],
            description: 'Type of deployment to perform'
        )
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Perform a dry run without making changes'
        )
        string(
            name: 'TERRAFORM_VERSION',
            defaultValue: '1.5.0',
            description: 'Terraform version to use'
        )
        string(
            name: 'ANSIBLE_VERSION',
            defaultValue: '2.15.0',
            description: 'Ansible version to use'
        )
    }
    
    stages {
        stage('Validate') {
            steps {
                script {
                    validatePrerequisites()
                }
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    setupEnvironment()
                }
            }
        }
        
        stage('Provision Infrastructure') {
            when {
                anyOf {
                    expression { params.DEPLOYMENT_TYPE == 'full' }
                    expression { params.DEPLOYMENT_TYPE == 'infrastructure' }
                }
            }
            steps {
                script {
                    provisionInfrastructure()
                }
            }
        }
        
        stage('Wait for VMs') {
            when {
                anyOf {
                    expression { params.DEPLOYMENT_TYPE == 'full' }
                    expression { params.DEPLOYMENT_TYPE == 'infrastructure' }
                }
            }
            steps {
                script {
                    waitForVMs()
                }
            }
        }
        
        stage('Configure Cluster') {
            when {
                anyOf {
                    expression { params.DEPLOYMENT_TYPE == 'full' }
                    expression { params.DEPLOYMENT_TYPE == 'configuration' }
                }
            }
            steps {
                script {
                    configureCluster()
                }
            }
        }
        
        stage('Deploy Workloads') {
            when {
                anyOf {
                    expression { params.DEPLOYMENT_TYPE == 'full' }
                    expression { params.DEPLOYMENT_TYPE == 'workloads' }
                }
            }
            steps {
                script {
                    deployWorkloads()
                }
            }
        }
        
        stage('Verify Deployment') {
            when {
                anyOf {
                    expression { params.DEPLOYMENT_TYPE == 'full' }
                    expression { params.DEPLOYMENT_TYPE == 'workloads' }
                }
            }
            steps {
                script {
                    verifyDeployment()
                }
            }
        }
        
        stage('Generate Report') {
            steps {
                script {
                    generateReport()
                }
            }
        }
    }
    
    post {
        always {
            script {
                cleanup()
            }
        }
        success {
            script {
                notifySuccess()
            }
        }
        failure {
            script {
                notifyFailure()
            }
        }
        aborted {
            script {
                notifyAborted()
            }
        }
    }
}

// Pipeline Functions

def validatePrerequisites() {
    echo "Validating prerequisites..."
    
    // Check if running on Windows
    if (isUnix()) {
        error "This pipeline must run on a Windows agent with Hyper-V support"
    }
    
    // Check Hyper-V availability
    powershell '''
        $hyperv = Get-WindowsFeature -Name Hyper-V-All
        if (-not $hyperv.Installed) {
            throw "Hyper-V is not installed on this system"
        }
        Write-Host "Hyper-V is available"
    '''
    
    // Check Docker availability
    powershell 'docker --version'
    
    // Check required tools
    powershell 'terraform --version'
    powershell 'ansible --version'
    
    echo "Prerequisites validation completed successfully"
}

def setupEnvironment() {
    echo "Setting up environment..."
    
    // Create workspace directories
    dir('infra/terraform') {
        sh 'mkdir -p .terraform'
    }
    
    dir('config/ansible') {
        sh 'mkdir -p inventories/dev'
    }
    
    // Set environment variables
    env.TF_VAR_environment = 'dev'
    env.TF_VAR_project_name = 'nomad-consul'
    
    echo "Environment setup completed"
}

def provisionInfrastructure() {
    echo "Provisioning infrastructure with Terraform..."
    
    dir('infra/terraform') {
        // Initialize Terraform
        if (params.DRY_RUN) {
            echo "DRY RUN: Would initialize Terraform"
        } else {
            sh 'terraform init'
        }
        
        // Plan changes
        if (params.DRY_RUN) {
            echo "DRY RUN: Would plan Terraform changes"
        } else {
            sh 'terraform plan -out=tfplan'
        }
        
        // Apply changes
        if (params.DRY_RUN) {
            echo "DRY RUN: Would apply Terraform changes"
        } else {
            sh 'terraform apply tfplan'
        }
        
        // Get outputs
        sh 'terraform output -json > outputs.json'
        
        // Parse outputs for later use
        def outputs = readJSON file: 'outputs.json'
        env.CONSUL_SERVERS = outputs.consul_servers.ips.join(',')
        env.NOMAD_SERVERS = outputs.nomad_servers.ips.join(',')
        env.NOMAD_CLIENTS = outputs.nomad_clients.ips.join(',')
    }
    
    echo "Infrastructure provisioning completed"
}

def waitForVMs() {
    echo "Waiting for VMs to become accessible..."
    
    def vmIps = (env.CONSUL_SERVERS + ',' + env.NOMAD_SERVERS + ',' + env.NOMAD_CLIENTS).split(',')
    
    vmIps.each { ip ->
        echo "Waiting for VM at ${ip}..."
        
        retry(30) {
            timeout(60) {
                powershell """
                    try {
                        $response = Test-NetConnection -ComputerName ${ip} -Port 22 -InformationLevel Quiet
                        if (-not $response) {
                            throw "Connection failed"
                        }
                        Write-Host "VM at ${ip} is accessible"
                    } catch {
                        throw "VM at ${ip} is not accessible yet"
                    }
                """
            }
        }
        
        // Wait additional time for OS to fully boot
        sleep(30)
    }
    
    echo "All VMs are now accessible"
}

def configureCluster() {
    echo "Configuring cluster with Ansible..."
    
    dir('config/ansible') {
        // Create SSH key file from Jenkins credentials
        withCredentials([sshUserPrivateKey(credentialsId: env.JENKINS_CREDENTIALS_ID, keyFileVariable: 'SSH_KEY_FILE')]) {
            // Run common configuration
            if (params.DRY_RUN) {
                echo "DRY RUN: Would run common Ansible playbook"
            } else {
                sh "ansible-playbook -i inventories/dev/hosts.yaml playbooks/common.yaml --private-key=${SSH_KEY_FILE}"
            }
            
            // Setup Consul cluster
            if (params.DRY_RUN) {
                echo "DRY RUN: Would setup Consul cluster"
            } else {
                sh "ansible-playbook -i inventories/dev/hosts.yaml playbooks/setup-consul.yaml --private-key=${SSH_KEY_FILE}"
            }
            
            // Setup Nomad cluster
            if (params.DRY_RUN) {
                echo "DRY RUN: Would setup Nomad cluster"
            } else {
                sh "ansible-playbook -i inventories/dev/hosts.yaml playbooks/setup-nomad.yaml --private-key=${SSH_KEY_FILE}"
            }
        }
    }
    
    echo "Cluster configuration completed"
}

def deployWorkloads() {
    echo "Deploying workloads to Nomad..."
    
    // Wait for cluster to be ready
    retry(10) {
        timeout(60) {
            sh "curl -f ${env.NOMAD_ADDR}/v1/status/leader"
        }
    }
    
    // Deploy example service
    dir('workloads/example-service') {
        if (params.DRY_RUN) {
            echo "DRY RUN: Would deploy example service"
        } else {
            sh "nomad job run nomad-job.hcl"
        }
    }
    
    // Deploy monitoring stack
    if (env.MONITORING_ENABLED == 'true') {
        dir('workloads/monitoring') {
            if (params.DRY_RUN) {
                echo "DRY RUN: Would deploy monitoring stack"
            } else {
                sh "nomad job run nomad-job.hcl"
            }
        }
    }
    
    echo "Workload deployment completed"
}

def verifyDeployment() {
    echo "Verifying deployment..."
    
    // Check Consul cluster health
    retry(5) {
        timeout(30) {
            def consulHealth = sh(
                script: "curl -s ${env.CONSUL_ADDR}/v1/status/peers | jq '. | length'",
                returnStdout: true
            ).trim()
            
            if (consulHealth.toInteger() < 3) {
                error "Consul cluster does not have enough peers for quorum"
            }
        }
    }
    
    // Check Nomad cluster health
    retry(5) {
        timeout(30) {
            def nomadHealth = sh(
                script: "curl -s ${env.NOMAD_ADDR}/v1/status/peers | jq '. | length'",
                returnStdout: true
            ).trim()
            
            if (nomadHealth.toInteger() < 3) {
                error "Nomad cluster does not have enough servers for quorum"
            }
        }
    }
    
    // Check workload status
    if (params.DEPLOYMENT_TYPE != 'infrastructure') {
        retry(5) {
            timeout(30) {
                def jobStatus = sh(
                    script: "nomad job status example-service",
                    returnStdout: true
                )
                
                if (!jobStatus.contains("Status = running")) {
                    error "Example service is not running"
                }
            }
        }
    }
    
    echo "Deployment verification completed successfully"
}

def generateReport() {
    echo "Generating deployment report..."
    
    def report = """
# Nomad + Consul Cluster Deployment Report

## Deployment Information
- **Build Number**: ${env.BUILD_NUMBER}
- **Build URL**: ${env.BUILD_URL}
- **Deployment Type**: ${params.DEPLOYMENT_TYPE}
- **Timestamp**: ${new Date().format("yyyy-MM-dd HH:mm:ss")}
- **Dry Run**: ${params.DRY_RUN}

## Infrastructure
- **Consul Servers**: ${env.CONSUL_SERVERS}
- **Nomad Servers**: ${env.NOMAD_SERVERS}
- **Nomad Clients**: ${env.NOMAD_CLIENTS}

## Access URLs
- **Consul UI**: http://${env.CONSUL_ADDR.replace('http://', '').replace(':8500', '')}:8500
- **Nomad UI**: http://${env.NOMAD_ADDR.replace('http://', '').replace(':4646', '')}:4646
- **Jenkins**: ${env.BUILD_URL}

## Status
- **Consul Cluster**: Healthy
- **Nomad Cluster**: Healthy
- **Workloads**: Deployed
"""
    
    writeFile file: 'deployment-report.md', text: report
    
    // Archive the report
    archiveArtifacts artifacts: 'deployment-report.md', fingerprint: true
    
    echo "Deployment report generated"
}

def cleanup() {
    echo "Performing cleanup..."
    
    // Clean up temporary files
    dir('infra/terraform') {
        sh 'rm -f tfplan outputs.json'
    }
    
    echo "Cleanup completed"
}

def notifySuccess() {
    echo "Deployment completed successfully!"
    
    // Send success notification
    // This could be Slack, email, or other notification method
    echo "Success notification sent"
}

def notifyFailure() {
    echo "Deployment failed!"
    
    // Send failure notification
    // This could be Slack, email, or other notification method
    echo "Failure notification sent"
}

def notifyAborted() {
    echo "Deployment was aborted!"
    
    // Send aborted notification
    echo "Aborted notification sent"
}
